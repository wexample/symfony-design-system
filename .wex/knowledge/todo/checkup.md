## Risques et améliorations
- Agrégation des assets : dans `AssetsAggregationService::buildAggregatedTags`, le dernier bloc agrégé est toujours écrit sous l’usage `extra-agg`, même s’il agrège un usage réel (perte de regroupement par usage). À corriger en flushant avec l’usage courant (ou en découpant l’agrégation par usage/contexte).
- Structure des tags : `AssetsService::buildTags` produit `type -> contexte -> usage`, alors que `assets/macros/assets.html.twig` itère `type -> usage -> contexte`. Les noms de groupe sont donc inversés (`css-layout-default` au lieu de `css-default-layout`), ce qui complique une consommation JS par usage. Il faudrait réaligner la structure (adapter la macro ou l’ordre produit).
- `AdaptiveResponseService::detectOutputType` suppose la présence d’une requête HTTP ; en contexte CLI ou test sans requête, cela lèvera une erreur. Ajouter un fallback (HTML par défaut) si `RequestStack::getCurrentRequest()` est null.
- Manifest front silencieux : `AssetsRegistry::loadManifest` ignore l’absence de `public/build/manifest.json`. En environnement prod, mieux vaut remonter une exception/log clair pour éviter des pages sans assets (ou exposer un indicateur de santé).
- Agrégation : `AssetsAggregationService` lit chaque fichier via `file_get_contents` sans gestion d’échec (retour `false`). Une garde explicite (exception/log) éviterait d’écrire des bundles agrégés vides/corrompus et faciliterait le diagnostic de permissions manquantes.
- Typage de `AssetTag::getAsset()` est non-nullable alors que des placeholders sont créés sans asset. Le rendre nullable ou éviter l’appel dans ces cas sécuriserait les consommateurs.
